var documenterSearchIndex = {"docs":
[{"location":"usage/#Usage-and-Examples","page":"Usage and Examples","title":"Usage and Examples","text":"","category":"section"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"To see all functionalities head to the API documentation. You can find some example notebooks in this repository.","category":"page"},{"location":"usage/#Indexing-nodes,-edges,-intents,-and-domains","page":"Usage and Examples","title":"Indexing nodes, edges, intents, and domains","text":"","category":"section"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"As we deal with multi-domain scenarios with partial knowledge, it becomes obvious that there cannot be  a single way to identify a node or edge since some nodes are not visible from outside a domain. However, an internal node might be needed to be addressed by external parties due to an intent statement. This leads to different indexing schemes that must be directed for intra-domain and inter-domain usage.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"In MINDFul.jl, we follow the example of Graphs.jl  and we index nodes as a sequence of Integers.","category":"page"},{"location":"usage/#Intra-domain-indexing","page":"Usage and Examples","title":"Intra-domain indexing","text":"","category":"section"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"The indexing of nodes for intra-domain usage is done just by a sequence of NODE_ID::Integer numbers. This means that the edges are defined as Edge(src::Integer, dst::Integer).","category":"page"},{"location":"usage/#Controller-level-indexing","page":"Usage and Examples","title":"Controller-level indexing","text":"","category":"section"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Intra-domain might not be so \"intra\". With the term intra-domain network, we refer to a network that has centralized control and belongs to one entity, i.e., network operator. However, this does not stop the network operator from logically separating the network. This could be done by having different SDN controllers responsible for different areas. Since the SDN controllers have partial knowledge of the network, a different indexing scheme is needed. So the same node, indexed before with a single Integer number, can now also be indexed with a Tuple{::Integer, ::Integer}. The first element of the Tuple is the id of the controller responsible for this node, and the second element is the local indexing of this node in the controller. In other words, a node can also be addressed as (CONTROLLER_ID, NODE_ID_IN_CONTROLLER). The CONTROLLER_ID might not always belong to an SDN controller as we might either have a stack of IBN framework instances, or the referenced node is a border node, i.e., belongs to a different domain,  and then the IBN framework instance of the neighbor domain must be referenced.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"To express this structure programmatically, we make use of  the NestedGraphs.jl package, where nodes are defined with a Tuple and edges with a NestedEdge where src and dst are Tuple{::Integer, Integer}.","category":"page"},{"location":"usage/#Inter-domain-indexing","page":"Usage and Examples","title":"Inter-domain indexing","text":"","category":"section"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Scaling up the previous idea, a domain node might also be globally referenced with a Tuple {::Integer, ::Integer}. This time the first element is the IBN domain id, and the second element is the node id inside the network as in Intra-domain indexing. In other words, a node can be addressed as (DOMAIN_ID, NODE_ID). The higher stacked IBN framework instance id is used to identify the domain. An edge can also be addressed globally with a NestedEdge.","category":"page"},{"location":"usage/#Intents-indexing","page":"Usage and Examples","title":"Intents indexing","text":"","category":"section"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"An intent can be globally indexed with a Tuple{::Integer, ::Integer}, i.e., (DOMAIN_ID, INTENT_ID). However, once the intent is compiled, a tree (or Directed Acyclic Graph, DAG ) of system-generated intents is generated. To globally reference such a system-generated intent,  we use the previous Tuple in combination with a UUID from UUIDs. In other words, we use Tuple {::Integer, ::Integer, ::UUID}. The first element is the highest in the hierarchy IBN id. The second element is the Intent id, i.e., the DAG id. The third element is the DAG node id.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"You can access all the submitted intents of an ibn::IBN with the ibn.intents field. So each intent will also have an index for this vector, which is not always the same as the intent DAG id.","category":"page"},{"location":"roadmap/#Roadmap","page":"Roadmap","title":"Roadmap","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"MINDFul.jl is an effort meant to help parties interested in the reasearch of intent-driven network coordination. Future additions are going to be determined by our research directions. However the following consitute a list of plans that are irrelevant to research purposes","category":"page"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"complete substitution of MetaGraphs by MetaGraphsNext\nintegration of Term.jl for more beautifl command-line operation\ndefinition of line rate units with Unitful.jl\nmore user-friendly interfaces","category":"page"},{"location":"#MINDFul.jl","page":"Introduction","title":"MINDFul.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"MINDFul.jl is a Framework for Intent-driven Multi-Domain Networks coordination. It provides the means for algorithmic research in the field of IP-Optical networking. It includes a stateful representation of common networking equipment and facilitates event-based simulations.","category":"page"},{"location":"#Introduction-to-intent-driven-networking","page":"Introduction","title":"Introduction to intent-driven networking","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Intent-driven Networking, or Intent-based Networking (IBN), is a paradigm that enables network operators to manage their network by expressing high-level desires (or intentions). Contrary to traditional rule-based or policy-based networking, in IBN, the network operator only needs to express WHAT needs to be done and not HOW. That means there is a shift towards a more declarative way of thinking.","category":"page"},{"location":"#Intents","page":"Introduction","title":"Intents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The building blocks of operating an intent-driven network are the intents, which, as described before, are the desires. The intents specify in an abstract way what needs to be done and under what requirements. From this point on, it is the task of the intent framework and not the network operator to process these intents and successfully produce an appropriate network configuration.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Each intent, once entered the network, is described by a state, the most common of which are:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"uncompiled: intent is just registered in the system and nothing more\ncompiled: there is an implementation of an intent\ncompiledfailed: compilation of the intent failed (e.g., due to scarce resources)\nuninstalled: intent is compiled but still not active in the network\ninstalled: intent is compiled and installed in the appropriate network elements\ninstallfailed: installation of the intent failed (e.g., due to network fault)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To compile an intent, MINDful.jl follows a novel technique where system-generated intents are produced and compiled, forming an intent tree. The more down we traverse the tree, the less abstract the intents become. The leaves of the tree are called low-level intents and are device-level intents.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"IBN can be applied anywhere in the OSI layers. However, MINDFul.jl is focused on the IP-Optical layers. An example of such an intent would be a connectivity intent between 2 nodes with specific QoS requirements.","category":"page"},{"location":"#Software-Defined-Networking-(SDN)","page":"Introduction","title":"Software-Defined Networking (SDN)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"IBN is commonly placed on top of an SDN controller. SDN separates the control and the data plane in a network. In other words, and as the name might suggest, SDN provides programmable reconfigurable networks. This is commonly achieved by having a centralized controller with global network knowledge and the ability to control and monitor the network elements.","category":"page"},{"location":"#IBN-over-SDN-architecture","page":"Introduction","title":"IBN over SDN architecture","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"MINDFul.jl follows the common architecture of placing the IBN framework on top of the SDN controller. The IBN framework contains all the logic and the intent system, and the SDN controller is the mediator that talks to the network devices. The SDN controller is necessary the same way a driver is for a computer. We might even have a stack of IBN framework instances before we end up with the driver being the SDN controller. This might be common for centralized multi-domain control.","category":"page"},{"location":"#Multi-Domain-(MD)-networking","page":"Introduction","title":"Multi-Domain (MD) networking","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"MD networking is a rather broad term and can span across different scenarios, such as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"centralized-controlled domains with global knowledge\ndecentralized-controlled domains with global knowledge\ndecentralized-controlled domains with partial knowledge","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The last scenario can be applied to domains belonging to different organizations, which is what the current package targets at best.","category":"page"},{"location":"#Role-of-MINDFul.jl","page":"Introduction","title":"Role of MINDFul.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"MINDFul.jl is a tool to facilitate research on state-of-the-art algorithms in decentralized multi-domain intent-driven networking. It provides interfaces to investigate various coordination and intent provision mechanisms.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"info: Info\nYou can learn more about the target architecture of MINDFul.jl in the following publication:F. Christou, \"Decentralized Intent-driven Coordination of Multi-Domain IP-Optical Networks,\" 2022 18th International Conference on Network and Service Management (CNSM), 2022, pp. 359-363, doi: 10.23919/CNSM55787.2022.9964606.","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [MINDFul]\nPrivate = false\nOrder   = [:function, :type]","category":"page"},{"location":"API/#MINDFul.addchild!-Union{Tuple{I}, Tuple{MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64}, Base.UUID, I}} where I<:Intent","page":"API","title":"MINDFul.addchild!","text":"addchild!(\n    idag::MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64},\n    parent::Base.UUID,\n    child::Intent\n) -> Union{Bool, IntentDAGNode{_A, MINDFul.LogState{Unitful.Quantity{Float64, 𝐓, Unitful.FreeUnits{(hr,), 𝐓, nothing}}, IntentState}} where _A<:Intent}\n\n\nAdd intent as to the DAG as a child to the intent with uuid parent.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.addchild!-Union{Tuple{I}, Tuple{MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64}, I}} where I<:Intent","page":"API","title":"MINDFul.addchild!","text":"addchild!(\n    idag::MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64},\n    intent::Intent\n) -> Union{Bool, IntentDAGNode{_A, MINDFul.LogState{Unitful.Quantity{Float64, 𝐓, Unitful.FreeUnits{(hr,), 𝐓, nothing}}, IntentState}} where _A<:Intent}\n\n\nAdd intent as to the DAG idag as a root.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.addintent!-Tuple{IBN, Intent}","page":"API","title":"MINDFul.addintent!","text":"addintent!(ibn::IBN, intent::Intent) -> Int64\n\n\nAdd intent to ibn as Network Operator. Returns the intent id.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.addintent!-Tuple{MINDFul.IBNIssuer, IBN, Intent}","page":"API","title":"MINDFul.addintent!","text":"addintent!(\n    ibnc::MINDFul.IBNIssuer,\n    ibnp::IBN,\n    intent::Intent\n) -> Int64\n\n\nThe IBN client ibnc asks to add intent intent to provider ibnp\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.anyreservations-Tuple{Any}","page":"API","title":"MINDFul.anyreservations","text":"anyreservations(ibn) -> Bool\n\n\nChecks if ibn has reserved something due to an intent or not\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.bordernodes-Tuple{IBN}","page":"API","title":"MINDFul.bordernodes","text":"bordernodes(ibn::IBN; subnetwork_view) -> Any\n\n\nReturn the border nodes, i.e. the nodes belonging to a different domain, of the IBN. If subnetwork_view = true the nodes are returned as a Vector{Tuple{Int,Int}} identifying (CONTROLLER_INDEX, NODE_ID). If subnetwork_view = false the nodes are returned as Vector{Int} with each element being the index of the node in ibn.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.connectIBNs!-Tuple{Vector{IBN}, Vector{NestedGraphs.NestedEdge}}","page":"API","title":"MINDFul.connectIBNs!","text":"connectIBNs!(\n    ibn::Vector{IBN},\n    cedges::Vector{NestedGraphs.NestedEdge}\n)\n\n\nConnect the ibn domains ibn using the global indexed Edges cedges.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.connectIBNs!-Union{Tuple{R}, Tuple{T}, Tuple{IBN, IBN, Array{NestedGraphs.NestedEdge{T}, 1}}, Tuple{IBN, IBN, Array{NestedGraphs.NestedEdge{T}, 1}, Union{Nothing, Array{Dict{Symbol, R}, 1}}}} where {T, R}","page":"API","title":"MINDFul.connectIBNs!","text":"connectIBNs!(\n    ibn1::IBN,\n    ibn2::IBN,\n    cedges::Array{NestedGraphs.NestedEdge{T}, 1}\n) -> Bool\nconnectIBNs!(\n    ibn1::IBN,\n    ibn2::IBN,\n    cedges::Array{NestedGraphs.NestedEdge{T}, 1},\n    dprops::Union{Nothing, Array{Dict{Symbol, R}, 1}}\n) -> Bool\n\n\nConnect ibn1 and ibn2 with the edges cedges with properties dprops.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.deploy!-Tuple{IBN, IBN, MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64}, IntentDAGNode, IntentTransition, MINDFul.IBNModus, Any}","page":"API","title":"MINDFul.deploy!","text":"\"\n\ndeploy!(\n    ibnc::IBN,\n    ibns::IBN,\n    dag::MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64},\n    idagn::IntentDAGNode,\n    itra::IntentTransition,\n    strategy::MINDFul.IBNModus,\n    algmethod;\n    time,\n    algargs...\n)\n\n\nThe IBN customer ibnc accesses the intent state machine of IBN server ibns and  commands the IntentTransition itra for the intent DAG node idagn of DAG dag  following the state-machine strategy IBNModus and the transition methodology algmethod.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.deploy!-Tuple{IBN, IBN, MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64}, IntentDAGNode, IntentTransition, MINDFul.IBNModus}","page":"API","title":"MINDFul.deploy!","text":"No algmethod provided\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.deploy!-Tuple{IBN, Int64, Vararg{Any}}","page":"API","title":"MINDFul.deploy!","text":"Assume intent is root of DAG\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.deploy!-Tuple{IBN, MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64}, Vararg{Any}}","page":"API","title":"MINDFul.deploy!","text":"Assume intent comes from Network Operator\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.descendants-Tuple{MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64}, IntentDAGNode}","page":"API","title":"MINDFul.descendants","text":"descendants(\n    dag::MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64},\n    idn::IntentDAGNode\n) -> Vector{IntentDAGNode}\n\n\nGet all descendants of DAG dag starting from node idn\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.distance-Tuple{F} where F<:FiberView","page":"API","title":"MINDFul.distance","text":"distance(\n    fv::FiberView\n) -> Unitful.Quantity{Float64, 𝐋, Unitful.FreeUnits{(km,), 𝐋, nothing}}\n\n\nGet length of the fiber fv\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.distance-Tuple{IBN, Vector{Int64}}","page":"API","title":"MINDFul.distance","text":"distance(ibn::IBN, path::Vector{Int64}) -> Any\n\n\nGet total distance of path in ibn\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.edgeify-Tuple{Any}","page":"API","title":"MINDFul.edgeify","text":"Converts a node path to a sequence of edges\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getintent-Tuple{IBN, Int64}","page":"API","title":"MINDFul.getintent","text":"getintent(\n    ibn::IBN,\n    intid::Int64\n) -> Union{Nothing, MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64}}\n\n\nGet intent of ibn with id intid\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getintentidxsfromissuer-Tuple{IBN, Int64, Int64}","page":"API","title":"MINDFul.getintentidxsfromissuer","text":"getintentidxsfromissuer(\n    ibn::IBN,\n    ibnid::Int64,\n    dagid::Int64\n) -> Vector{Int64}\n\n\nGet all intent indices from ibn to which the issuer is the IBN with id ibnid and delegated intent dagid.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getintentidxsfromissuer-Tuple{IBN, Int64}","page":"API","title":"MINDFul.getintentidxsfromissuer","text":"getintentidxsfromissuer(\n    ibn::IBN,\n    ibnid::Int64\n) -> Vector{Int64}\n\n\nGet all intent indices from ibn to which the issuer is the IBN with id ibnid.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getintentissuer-Tuple{IBN, Int64}","page":"API","title":"MINDFul.getintentissuer","text":"getintentissuer(\n    ibn::IBN,\n    intid::Int64\n) -> Union{Nothing, MINDFul.IntentIssuer}\n\n\nGet the issuer of the intent with id intid in ibn\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getremoteintentsid-Tuple{IBN, MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64}}","page":"API","title":"MINDFul.getremoteintentsid","text":"getremoteintentsid(\n    ibn::IBN,\n    dag::MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64}\n) -> Vector{Tuple{Int64, Int64}}\n\n\nGet all RemoteIntents of dag of ibn\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.getuserintent-Tuple{MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64}}","page":"API","title":"MINDFul.getuserintent","text":"getuserintent(\n    idag::MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64}\n) -> IntentDAGNode\n\n\nReturn the user intent\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.issatisfied-Tuple{IBN, Int64}","page":"API","title":"MINDFul.issatisfied","text":"onlylogic is WIP\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.issatisfied-Union{Tuple{I}, Tuple{IBN, MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64}, IntentDAGNode{I}}} where I<:Intent","page":"API","title":"MINDFul.issatisfied","text":"issatisfied(\n    ibn::IBN,\n    dag::MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64},\n    idagn::IntentDAGNode{I<:Intent}\n) -> Union{Missing, Bool}\n\n\nCheck if intent of ibn,dag,idagn is satisfied. It checks whether the implementation of the intent makes sense and if all constraints are satisfied. Internally it retrieves all low-level intents, assembles them, and decides whether or not they satisfy the intent.\n\nThis function assumes global knowledge to reach a verdict. For this reason it is clearly a function used for simulation purposes.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.issatisfied-Union{Tuple{K}, Tuple{Vector{MINDFul.IBNnIntentGLLI}, Vector{K}, CapacityConstraint}} where K<:Union{Missing, MINDFul.ConnectionState}","page":"API","title":"MINDFul.issatisfied","text":"issatisfied(\n    globalIBNnllis::Vector{MINDFul.IBNnIntentGLLI},\n    vcs::Array{K<:Union{Missing, MINDFul.ConnectionState}, 1},\n    cc::CapacityConstraint\n) -> Bool\n\n\nCheck whether the gloval low-level intents globalIBNnllis and their logical states vcs satisfy the capacity constraints cc. Low Level Intents are assumed to be installed now.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.issatisfied-Union{Tuple{K}, Tuple{Vector{MINDFul.IBNnIntentGLLI}, Vector{K}, DelayConstraint}} where K<:Union{Missing, MINDFul.ConnectionState}","page":"API","title":"MINDFul.issatisfied","text":"issatisfied(\n    globalIBNnllis::Vector{MINDFul.IBNnIntentGLLI},\n    vcs::Array{K<:Union{Missing, MINDFul.ConnectionState}, 1},\n    cc::DelayConstraint\n) -> Bool\n\n\nCheck whether the gloval low-level intents globalIBNnllis and their logical states vcs satisfy the constraints cc. Low Level Intents are assumed to be installed now.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.issatisfied-Union{Tuple{K}, Tuple{Vector{MINDFul.IBNnIntentGLLI}, Vector{K}, GoThroughConstraint}} where K<:Union{Missing, MINDFul.ConnectionState}","page":"API","title":"MINDFul.issatisfied","text":"issatisfied(\n    globalIBNnllis::Vector{MINDFul.IBNnIntentGLLI},\n    vcs::Array{K<:Union{Missing, MINDFul.ConnectionState}, 1},\n    cc::GoThroughConstraint\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.issatisfied-Union{Tuple{R}, Tuple{IBN, MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64}, IntentDAGNode{R}}} where R<:MINDFul.NodeRouterIntent","page":"API","title":"MINDFul.issatisfied","text":"issatisfied(\n    ibn::IBN,\n    dag::MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64},\n    nri::IntentDAGNode{R<:MINDFul.NodeRouterIntent}\n) -> Union{Missing, Bool}\n\n\nCheck if the NodeRouterIntent nri of dag is satisfied in ibn.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.issatisfied-Union{Tuple{R}, Tuple{IBN, MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64}, IntentDAGNode{R}}} where R<:MINDFul.NodeSpectrumIntent","page":"API","title":"MINDFul.issatisfied","text":"issatisfied(\n    ibn::IBN,\n    dag::MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64},\n    nsi::IntentDAGNode{R<:MINDFul.NodeSpectrumIntent}\n) -> Bool\n\n\nCheck if the NodeSpectrumIntent nsi of dag is satisfied in ibn.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.nestedGraph2IBNs!-Tuple{NestedGraphs.NestedGraph}","page":"API","title":"MINDFul.nestedGraph2IBNs!","text":"nestedGraph2IBNs!(\n    globalnet::NestedGraphs.NestedGraph\n) -> Vector{IBN{SDNdummy{Int64}}}\n\n\nConvert globalnet to a NestedGraph using IBN framework instances and SDN controllers.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.randomsimgraph!-Tuple{MetaGraphs.MetaDiGraph}","page":"API","title":"MINDFul.randomsimgraph!","text":"randomsimgraph!(\n    mgr::MetaGraphs.MetaDiGraph\n) -> MetaGraphs.MetaDiGraph\n\n\nGet a random graph able to simulate\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.remintent!-Tuple{IBN, Int64}","page":"API","title":"MINDFul.remintent!","text":"remintent!(ibn::IBN, idi::Int64) -> Bool\n\n\nRemove intent with id idi from ibn. Returns true if successful.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.remintent!-Tuple{MINDFul.IBNIssuer, IBN, Int64}","page":"API","title":"MINDFul.remintent!","text":"remintent!(\n    ibnc::MINDFul.IBNIssuer,\n    ibns::IBN,\n    intentid::Int64\n) -> Bool\n\n\nThe IBN client ibnc asks to remove intent with id intentid to provider ibnp\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.set_operation_status!-Tuple{IBN, FiberView, Bool}","page":"API","title":"MINDFul.set_operation_status!","text":"set_operation_status!(\n    ibn::IBN,\n    device::FiberView,\n    status::Bool;\n    time,\n    forcelog\n)\n\n\nSet fiber device of ibn at status status in time time. Use forcelog to force or not a logging.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.simgraph-Tuple{G} where G<:(NestedGraphs.NestedMetaGraph)","page":"API","title":"MINDFul.simgraph","text":"simgraph(\n    ng::NestedGraphs.NestedMetaGraph;\n    distance_method\n) -> Any\n\n\nBuilds a nested graph from ng able to simulate.\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.simgraph-Tuple{MetaGraphs.MetaDiGraph}","page":"API","title":"MINDFul.simgraph","text":"simgraph(\n    mgr::MetaGraphs.MetaDiGraph;\n    distance_method\n) -> MetaGraphs.MetaDiGraph{_A, Float64} where _A<:Integer\n\n\nBuilds a graph from mgr able to simulate. Pass in mgr having:\n\n:routerports as integer in every node\n:xcoord as integer in every node\n:ycoord as integer in every node\n:oxc as boolean in every node\n:fiberslots as int in every link\n\nGet as an output a MetaGraph having:\n\n:xcoord as integer in every node\n:ycoord as integer in every node\n:router as RouterView in every node\n:link as FiberView in every edge\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.ConnectivityIntent","page":"API","title":"MINDFul.ConnectivityIntent","text":"struct ConnectivityIntent{C, R} <: Intent\n\nsrc::Tuple{Int64, Int64}: Source node as (IBN.id, node-id)\ndst::Tuple{Int64, Int64}: Destination node as (IBN.id, node-id)\nconstraints::Any: Intents constraints\nconditions::Any: Intents conditions\n\nIntent for connecting 2 nodes\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.IBN","page":"API","title":"MINDFul.IBN","text":"struct IBN{T<:SDN}\n\nid::Int64: id of IBN\nintents::Vector{MetaGraphsNext.MetaDiGraph{Int64, Base.UUID, Graphs.SimpleGraphs.SimpleDiGraph{Int64}, IntentDAGNode, Nothing, MINDFul.IntentDAGInfo, MetaGraphsNext.var\"#3#5\", Float64}}: The intent collection of the IBN Framework\nintentissuers::Vector{MINDFul.IntentIssuer}\ncontrollers::Array{Union{IBN, T}, 1} where T<:SDN: The collection of SDNs controlled from this IBN Framework and interacting IBNs (future should be IBN-NBIs)\nngr::NestedGraphs.NestedMetaGraph{Int64, MetaGraphs.MetaDiGraph{Int64, Float64}, MetaGraphs.MetaDiGraph{Int64, Float64}}: Nested Graph consisting of the several SDNs ngr is a shallow copy of the sdn graphs, meaning all PHY information is available in the IBN\n\ninterprops::Dict{Int64, MINDFul.IBNInterProps}: InterIBN interoperability with key being the IBN id\n\nThe Intent Framework The intent id is the vector index controllers must have same length with ngr.grv\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.IBN-Union{Tuple{T}, Tuple{Int64, Type{T}}} where T<:SDN","page":"API","title":"MINDFul.IBN","text":"Empty constructor\n\n\n\n\n\n","category":"method"},{"location":"API/#MINDFul.IntentDAGNode","page":"API","title":"MINDFul.IntentDAGNode","text":"mutable struct IntentDAGNode{T<:Intent, L<:MINDFul.LogState}\n\nintent::Intent\nstate::IntentState\nid::Base.UUID\nlogstate::MINDFul.LogState\n\n\n\n\n\n","category":"type"},{"location":"API/#MINDFul.SDNdummy","page":"API","title":"MINDFul.SDNdummy","text":"A dummy SDN controller to use for research and experiment purposes. This SDN controller is directly connected with the simulated physical layer network resources SimNetResou.jl\n\ngr::MetaGraphs.MetaDiGraph{T} where T: network of SDN\ninterprops::Dict{NestedGraphs.NestedEdge, Dict{Symbol, Any}}: inter domain equipment(e.g. links)\n\n\n\n\n\n","category":"type"},{"location":"API/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"","category":"page"}]
}
